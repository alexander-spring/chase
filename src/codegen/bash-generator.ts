import * as fs from 'fs';
import * as path from 'path';

export interface GeneratorOptions {
  cdpUrl: string;
  outputDir: string;
  filename?: string;
}

/**
 * Write a script to file
 */
export function writeScript(
  scriptContent: string,
  options: GeneratorOptions
): string {
  const { outputDir, filename } = options;

  // Generate filename if not provided
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
  const scriptFilename = filename || `script-${timestamp}.sh`;
  const outputPath = path.join(outputDir, scriptFilename);

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write script file
  fs.writeFileSync(outputPath, scriptContent);
  fs.chmodSync(outputPath, '755');

  return outputPath;
}

/**
 * Generate a standalone bash script from captured commands (legacy function)
 * Now simplified to just process the script for variable normalization
 */
export function generateBashScript(
  commands: string[],
  options: GeneratorOptions
): string {
  const { cdpUrl, outputDir, filename } = options;

  // Generate filename if not provided
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
  const scriptFilename = filename || `script-${timestamp}.sh`;
  const outputPath = path.join(outputDir, scriptFilename);

  // Filter and process commands
  const processedCommands: string[] = [];

  for (const cmd of commands) {
    // Skip snapshot commands
    if (cmd.includes('snapshot')) continue;

    // Skip screenshot commands
    if (cmd.includes('screenshot')) continue;

    // Skip commands with ephemeral refs
    if (/@e\d+/.test(cmd)) {
      processedCommands.push(`# SKIP: Uses ephemeral ref`);
      processedCommands.push(`# ${cmd}`);
      continue;
    }

    let processed = cmd;

    // Normalize CDP variable references
    processed = processed.replace(/"\$CDP_URL"/g, '"$CDP"');
    processed = processed.replace(/'\$CDP_URL'/g, '"$CDP"');
    processed = processed.replace(/\$CDP_URL/g, '$CDP');
    processed = processed.replace(cdpUrl, '$CDP');
    processed = processed.replace(`"${cdpUrl}"`, '"$CDP"');

    // Ensure proper --cdp quoting
    processed = processed.replace(/--cdp\s+\$CDP(?!\w)/g, '--cdp "$CDP"');

    processedCommands.push(processed);

    // Add sleep after navigation
    if (cmd.includes(' open ')) {
      processedCommands.push('sleep 2');
    }
  }

  // Build script content
  const scriptLines: string[] = [
    '#!/bin/bash',
    'set -e',
    '',
    '# Generated by claude-gen',
    `# Created: ${new Date().toISOString()}`,
    '',
    'CDP="${CDP_URL:?Required: CDP_URL}"',
    '',
    ...processedCommands,
    '',
    'echo ""',
    'echo "============================================"',
    'echo "FINAL RESULTS"',
    'echo "============================================"',
    'echo "Script completed"',
  ];

  const scriptContent = scriptLines.join('\n');

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write script file
  fs.writeFileSync(outputPath, scriptContent);
  fs.chmodSync(outputPath, '755');

  return outputPath;
}

/**
 * Normalize a script's CDP variable references
 */
export function normalizeScriptCdp(script: string, cdpUrl: string): string {
  let normalized = script;

  // Replace hardcoded CDP URL
  normalized = normalized.replace(new RegExp(escapeRegex(cdpUrl), 'g'), '$CDP');

  // Normalize variable references
  normalized = normalized.replace(/"\$CDP_URL"/g, '"$CDP"');
  normalized = normalized.replace(/'\$CDP_URL'/g, '"$CDP"');
  normalized = normalized.replace(/\$CDP_URL/g, '$CDP');

  return normalized;
}

function escapeRegex(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
